# model for increment alone

import cocotb
from cocotb_coverage.coverage import *
with open('MAC_binary.txt', 'r') as file:
    # Read all lines into a list
    lines_MAC = file.readlines()

counter_coverage = coverage_section(
    CoverPoint('top.mac_int_input_inp_1', vname='a', bins = [
    "00000001", "00000010", "00000100", "00001000", "00010000", "00100000", "01000000", "10000000",
    "11111110", "11111101", "11111011", "11110111", "11101111", "11011111", "10111111", "01111111",
    "10101010", "01010101", "00000000", "01111111", "10000000", "00111100", "11000010", "01111010",
    "11010101", "11111111"
]),
    CoverPoint('top.mac_int_input_inp_2', vname='b', bins = [
    "00000001", "00000010", "00000100", "00001000", "00010000", "00100000", "01000000", "10000000",
    "11111110", "11111101", "11111011", "11110111", "11101111", "11011111", "10111111", "01111111",
    "10101010", "01010101", "00000000", "01111111", "10000000", "00111100", "11000010", "01111010",
    "11010101", "11111111"
]),
    CoverPoint('top.mac_int_input_inp_3', vname='c', bins =[
    "00000000000000000000000000000001", "00000000000000000000000000000010", 
    "00000000000000000000000000000100", "00000000000000000000000000001000", 
    "00000000000000000000000000010000", "00000000000000000000000000100000", 
    "00000000000000000000000001000000", "00000000000000000000000010000000", 
    "00000000000000000000000100000000", "00000000000000000000001000000000", 
    "00000000000000000000010000000000", "00000000000000000000100000000000", 
    "00000000000000000001000000000000", "00000000000000000010000000000000", 
    "00000000000000000100000000000000", "00000000000000001000000000000000", 
    "00000000000000010000000000000000", "00000000000000100000000000000000", 
    "00000000000001000000000000000000", "00000000000010000000000000000000", 
    "00000000000100000000000000000000", "00000000001000000000000000000000", 
    "00000000010000000000000000000000", "00000000100000000000000000000000", 
    "00000001000000000000000000000000", "00000010000000000000000000000000", 
    "00000100000000000000000000000000", "00001000000000000000000000000000", 
    "00010000000000000000000000000000", "00100000000000000000000000000000", 
    "01000000000000000000000000000000", "10000000000000000000000000000000", 
    "11111111111111111111111111111111", "00000000000000000000000000000000", 
    "01111111111111111111111111111111", "10000000000000000000000000000000", 
    "00111111111111111111111111111111", "11000000111000000111000000111000", 
    "11110000111100001111000011110000", "10101010101010101010101010101010", 
    "01010101010101010101010101010101"
] ),
    CoverCross('top.cross_cover', items = ['top.mac_int_input_inp_1', 'top.mac_int_input_inp_2','top.mac_int_input_inp_3'])
)
def output(a: str, b: str, c: str):
    
    def to_signed_int(binary_str, bits):
        
        if binary_str[0] == '1':
            
            return int(binary_str, 2) - (1 << bits)
        return int(binary_str, 2)

   
    a_int = to_signed_int(a, 8)
    b_int = to_signed_int(b, 8)
    c_int = to_signed_int(c, 32)

    result = a_int * b_int

    result_32bit = format(result & 0xFFFFFFFF, '032b')  
    sum_result = int(result_32bit, 2) + c_int
    sum_result_32bit = format(sum_result & 0xFFFFFFFF, '032b')  
    return sum_result_32bit

@counter_coverage
def model_macint32(a,b,c) -> int:
    return output(a,b,c)
